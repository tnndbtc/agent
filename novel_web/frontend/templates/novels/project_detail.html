{% extends 'base.html' %}
{% load i18n %}

{% block title %}{{ project.title }} - {% trans "Novel Writing Agent" %}{% endblock %}
{% block nav_title %}{{ project.title }}{% endblock %}

{% block content %}
<div class="project-detail">
    <!-- Tabs -->
    <div class="tabs">
        <button class="tab active" data-tab="overview">{% trans "Overview" %}</button>
        <button class="tab" data-tab="chapters">{% trans "Chapters" %}</button>
        <button class="tab" data-tab="tools">{% trans "Tools" %}</button>
    </div>

    <!-- Overview Tab -->
    <div class="tab-content active" id="overview">
        <div class="section">
            <h3>{% trans "Project Info" %}</h3>
            <div class="info-grid">
                <div class="info-item">
                    <label>{% trans "Status" %}</label>
                    <span class="status-badge status-{{ project.status }}">{{ project.get_status_display }}</span>
                </div>
                <div class="info-item">
                    <label>{% trans "Genre" %}</label>
                    <span>{{ project.genre|default:"Not set" }}</span>
                </div>
                <div class="info-item">
                    <label>{% trans "Total Words" %}</label>
                    <span>{{ project.total_word_count|default:0 }}</span>
                </div>
                <div class="info-item">
                    <label>{% trans "Chapters" %}</label>
                    <span>{{ chapters|length }}</span>
                </div>
            </div>
        </div>

        <!-- Ideas Section (Embedded Brainstorm Functionality) -->
        <div class="section brainstorm-section">
            <h3>{% trans "Ideas" %}</h3>

            <!-- Previously Saved Ideas - Show when idea exists -->
            {% if previous_ideas %}
            <div class="saved-ideas-section" style="margin-top: 1rem;">
                <h4 style="margin-bottom: 1rem;">My Idea</h4>
                <div class="ideas-container">
                    {% for idea in previous_ideas|slice:":1" %}
                    <div class="idea-card current-idea">
                        <div class="idea-premise" style="font-size: 1rem; margin-bottom: 1rem;">
                            {% firstof idea.premise idea.description "No description" %}
                        </div>
                        {% if idea.genre %}
                        <div class="idea-tags">
                            <span class="tag">{{ idea.genre }}</span>
                        </div>
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>

                <div id="createPlotProgressContainer" class="progress-container" style="display: none; margin-top: 1rem;">
                    <div class="progress-bar">
                        <div id="createPlotProgressBarFill" class="progress-bar-fill">0%</div>
                    </div>
                    <div id="createPlotProgressText" class="progress-text">Creating plot & characters...</div>
                </div>

                <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                    <button class="btn btn-primary" onclick="modifyIdea()">
                        ‚úèÔ∏è Modify Idea
                    </button>
                    <button class="btn btn-primary" onclick="useCurrentIdea()" id="createPlotBtn">
                        ‚ú® Create Plot & Characters
                    </button>
                </div>
            </div>

            <!-- Edit Form - Hidden by default -->
            <div id="editSection" style="display: none; margin-top: 1.5rem;">
                <form id="editForm" class="form-card">
                    <div class="form-group">
                        <label for="edit_premise">Idea</label>
                        <textarea id="edit_premise" name="premise" class="form-control" rows="4" required
                                  placeholder="Describe your plot idea...">{% firstof previous_ideas.0.premise previous_ideas.0.description "" %}</textarea>
                    </div>

                    <div class="form-group">
                        <label>{% trans "Genre" %}</label>
                        <div class="genre-display">{{ project.genre|default:"Not specified" }}</div>
                    </div>

                    <div style="display: flex; gap: 1rem;">
                        <button type="submit" class="btn btn-primary" style="flex: 1;">
                            üíæ Save Changes
                        </button>
                        <button type="button" class="btn btn-secondary" onclick="cancelEdit()">
                            Cancel
                        </button>
                    </div>
                </form>
            </div>

            {% else %}
            <!-- Original Brainstorm Page - Only shown when no ideas exist -->
            <div class="info-message">
                <p>{% trans "Generate creative plot ideas for your novel. You can customize the genre, theme, and number of ideas to generate." %}</p>
            </div>

            <!-- Mode Toggle -->
            <div class="mode-toggle">
                <button type="button" class="mode-btn active" data-mode="generate" onclick="switchMode('generate')">
                    ü§ñ Generate Ideas
                </button>
                <button type="button" class="mode-btn" data-mode="manual" onclick="switchMode('manual')">
                    ‚úçÔ∏è Manual Input
                </button>
            </div>

            <!-- AI Generation Form -->
            <form id="brainstormForm" class="form-card" style="display: block;">
                <div class="form-group">
                    <label>{% trans "Genre" %}</label>
                    <div class="genre-display">{{ project.genre|default:"Not specified" }}</div>
                </div>

                <div class="form-group">
                    <label for="theme">{% trans "Theme" %} ({% trans "optional" %})</label>
                    <input type="text" id="theme" name="theme" class="form-control"
                           placeholder="{% trans "e.g., Redemption, Coming of age, Good vs Evil" %}">
                    <small class="form-text">{% trans "Enter a theme to guide the brainstorming" %}</small>
                </div>

                <div class="form-group">
                    <label for="num_ideas">{% trans "Number of Ideas" %}</label>
                    <input type="number" id="num_ideas" name="num_ideas" class="form-control"
                           value="3" min="1" max="20" required>
                    <small class="form-text">{% trans "Enter a number between 1 and 20" %}</small>
                </div>

                <div id="brainstormProgressContainer" class="progress-container" style="display: none;">
                    <div class="progress-bar">
                        <div id="brainstormProgressBarFill" class="progress-bar-fill">0%</div>
                    </div>
                    <div id="brainstormProgressText" class="progress-text">Generating ideas...</div>
                </div>

                <button type="submit" class="btn btn-primary btn-block" id="generateIdeasBtn">
                    {% trans "Generate Ideas" %}
                </button>
            </form>

            <!-- Manual Input Form -->
            <form id="manualForm" class="form-card" style="display: none;">
                <div class="form-group">
                    <label for="manual_premise">Idea</label>
                    <textarea id="manual_premise" name="premise" class="form-control" rows="4" required
                              placeholder="Describe your plot idea..."></textarea>
                </div>

                <div class="form-group">
                    <label>{% trans "Genre" %}</label>
                    <div class="genre-display">{{ project.genre|default:"Not specified" }}</div>
                </div>

                <div id="progressContainer" class="progress-container">
                    <div class="progress-bar">
                        <div id="progressBarFill" class="progress-bar-fill">0%</div>
                    </div>
                    <div id="progressText" class="progress-text">Saving idea and creating plot & characters...</div>
                </div>

                <button type="submit" class="btn btn-primary btn-block" id="saveIdeaBtn">
                    üíæ Save Idea and continue
                </button>
            </form>

            <div id="resultsSection" class="results-section" style="display: none;">
                <h3>{% trans "Generated Ideas" %}</h3>
                <div id="ideasContainer" class="ideas-container"></div>
            </div>
            {% endif %}
        </div>

        <!-- Plot Section -->
        <div class="section">
            <h3>{% trans "Plot Structure" %}</h3>
            {% if has_plot %}
            <div class="plot-display">
                <div class="plot-field">
                    <label>{% trans "Premise" %}</label>
                    <p>{{ project.plot.premise }}</p>
                </div>
                <div class="plot-field">
                    <label>{% trans "Genre" %}</label>
                    <p>{{ project.plot.genre }}</p>
                </div>
                <div class="plot-field">
                    <label>{% trans "Themes" %}</label>
                    <p>{{ project.plot.themes }}</p>
                </div>
                <div class="plot-field">
                    <label>{% trans "Conflict" %}</label>
                    <p>{{ project.plot.conflict }}</p>
                </div>
            </div>
            {% else %}
            <div class="empty-state">
                <p>{% trans "No plot created yet. Plot will be auto-generated from your brainstorm ideas." %}</p>
            </div>
            {% endif %}
        </div>

        <!-- Characters Section -->
        <div class="section">
            <h3>{% trans "Characters" %}</h3>
            {% if characters %}
            <div class="characters-list">
                {% for character in characters %}
                <div class="character-card">
                    <div class="character-header">
                        <h4>{{ character.name }}</h4>
                        <span class="role-badge">{{ character.get_role_display }}</span>
                    </div>
                    <p class="character-bio">{{ character.background|truncatewords:30 }}</p>
                </div>
                {% endfor %}
            </div>
            {% else %}
            <div class="empty-state">
                <p>{% trans "No characters yet. Characters will be auto-generated based on plot." %}</p>
            </div>
            {% endif %}
        </div>
    </div>

    <!-- Chapters Tab -->
    <div class="tab-content" id="chapters">
        <div class="section">
            <div class="section-header">
                <h3>{% trans "Chapters" %}</h3>
                <div class="button-group">
                    {% if outlines %}
                    <button class="btn btn-secondary" onclick="createOutline()">{% trans "Add Outline" %}</button>
                    <button class="btn btn-primary" onclick="writeNextChapter()">{% trans "Write Chapter" %}</button>
                    {% else %}
                    <button class="btn btn-primary" onclick="createOutline()">{% trans "Create Outline" %}</button>
                    {% endif %}
                </div>
            </div>

            <div id="createOutlineProgressContainer" class="progress-container" style="display: none; margin-top: 1rem;">
                <div class="progress-bar">
                    <div id="createOutlineProgressBarFill" class="progress-bar-fill">0%</div>
                </div>
                <div id="createOutlineProgressText" class="progress-text">Saving idea and creating plot & characters...</div>
            </div>

            {% if outlines %}
            <div class="outlines-section">
                <h4>{% trans "Chapter Outlines" %}</h4>
                <div class="outlines-list">
                    {% for outline in outlines %}
                    <div class="outline-card">
                        <div class="outline-header">
                            <span class="outline-number">{{ outline.number }}</span>
                            <h5>{{ outline.title }}</h5>
                        </div>
                        <div class="outline-details">
                            {% if outline.pov %}
                            <p><strong>{% trans "POV:" %}</strong> {{ outline.pov }}</p>
                            {% endif %}
                            {% if outline.setting %}
                            <p><strong>{% trans "Setting:" %}</strong> {{ outline.setting }}</p>
                            {% endif %}
                            {% if outline.events %}
                            <p><strong>{% trans "Events:" %}</strong> {{ outline.events|truncatewords:30 }}</p>
                            {% endif %}
                            {% if outline.pacing %}
                            <p><strong>{% trans "Pacing:" %}</strong> {{ outline.pacing }}</p>
                            {% endif %}
                        </div>

                        {% if outline.chapter %}
                        <!-- Written Chapter -->
                        <div class="written-chapter-preview">
                            <div class="chapter-header">
                                <h5>{% trans "Written Chapter" %}</h5>
                                {% if outline.chapter.is_draft %}
                                <span class="badge badge-warning">{% trans "Draft" %}</span>
                                {% else %}
                                <span class="badge badge-success">{% trans "Complete" %}</span>
                                {% endif %}
                            </div>
                            <p class="chapter-stats">
                                {{ outline.chapter.word_count }} {% trans "words" %} ‚Ä¢
                                {% trans "Updated" %} {{ outline.chapter.updated_at|timesince }} {% trans "ago" %}
                            </p>
                            <div class="chapter-preview-actions">
                                <button class="btn btn-sm btn-primary" onclick="window.location.href='{% url 'novels:chapter_detail' project.id outline.chapter.id %}'">
                                    {% trans "View/Edit Chapter" %}
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); deleteChapter('{{ outline.chapter.id }}')">
                                    {% trans "Delete Chapter" %}
                                </button>
                            </div>
                        </div>
                        {% else %}
                        <!-- Outline Actions (only show if no chapter written) -->
                        <div id="writeChapterProgressContainer-{{ outline.id }}" class="progress-container" style="display: none; margin-bottom: 1rem;">
                            <div class="progress-bar">
                                <div id="writeChapterProgressBarFill-{{ outline.id }}" class="progress-bar-fill">0%</div>
                            </div>
                            <div id="writeChapterProgressText-{{ outline.id }}" class="progress-text">Saving idea and creating plot & characters...</div>
                        </div>
                        <div id="regenerateProgressContainer-{{ outline.number }}" class="progress-container" style="display: none; margin-bottom: 1rem;">
                            <div class="progress-bar">
                                <div id="regenerateProgressBarFill-{{ outline.number }}" class="progress-bar-fill">0%</div>
                            </div>
                            <div id="regenerateProgressText-{{ outline.number }}" class="progress-text">Saving idea and creating plot & characters...</div>
                        </div>
                        <div class="outline-actions">
                            <button class="btn btn-sm btn-primary" onclick="writeChapterFromOutline('{{ outline.id }}')" id="writeChapterBtn-{{ outline.id }}">
                                {% trans "Write This Chapter" %}
                            </button>
                            <button class="btn btn-sm btn-secondary" onclick="regenerateOutline({{ outline.number }})" id="regenerateBtn-{{ outline.number }}">
                                {% trans "Regenerate" %}
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="deleteOutline('{{ outline.id }}')">
                                {% trans "Delete" %}
                            </button>
                        </div>
                        {% endif %}
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endif %}

            {% if chapters and not outlines %}
            <!-- Show standalone chapters only if there are no outlines -->
            <div class="chapters-section">
                <h4>{% trans "Written Chapters" %}</h4>
                <div class="chapters-list">
                    {% for chapter in chapters %}
                    <div class="chapter-card">
                        <div class="chapter-number">{{ chapter.chapter_number }}</div>
                        <div class="chapter-info" onclick="window.location.href='{% url 'novels:chapter_detail' project.id chapter.id %}'" style="cursor: pointer; flex: 1;">
                            <h4>{{ chapter.title }}</h4>
                            <p>{{ chapter.word_count }} {% trans "words" %} ‚Ä¢ {{ chapter.updated_at|timesince }} {% trans "ago" %}</p>
                        </div>
                        <div class="chapter-status">
                            {% if chapter.is_draft %}
                            <span class="badge badge-warning">{% trans "Draft" %}</span>
                            {% else %}
                            <span class="badge badge-success">{% trans "Complete" %}</span>
                            {% endif %}
                        </div>
                        <div class="chapter-actions">
                            <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); deleteChapter('{{ chapter.id }}')">
                                {% trans "Delete" %}
                            </button>
                        </div>
                    </div>
                    {% endfor %}
                </div>
            </div>
            {% endif %}

            {% if not outlines and not chapters %}
            <div class="empty-state">
                <p>{% trans "No chapters written yet. Create an outline to start writing!" %}</p>
            </div>
            {% endif %}
        </div>
    </div>

    <!-- Tools Tab -->
    <div class="tab-content" id="tools">
        <div class="section">
            <h3>{% trans "Writing Tools" %}</h3>
            <div class="tools-grid">
                <button class="tool-card" onclick="checkConsistency()">
                    <span class="tool-icon">üîç</span>
                    <h4>{% trans "Check Consistency" %}</h4>
                    <p>{% trans "Verify character traits, settings, and timeline" %}</p>
                </button>
                <button class="tool-card" onclick="scoreNovel()">
                    <span class="tool-icon">‚≠ê</span>
                    <h4>{% trans "Score Novel" %}</h4>
                    <p>{% trans "Get AI feedback on your writing" %}</p>
                </button>
                <div class="tool-card">
                    <span class="tool-icon">üì•</span>
                    <h4>{% trans "Export" %}</h4>
                    <p>{% trans "Download or view your novel" %}</p>
                    <div class="export-actions">
                        <button class="btn btn-sm btn-primary" onclick="downloadNovel()">
                            {% trans "Download" %}
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="viewNovelOnline()">
                            {% trans "View Online" %}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
/* Brainstorm Section Styles */
.brainstorm-section .info-message {
    background: #eff6ff;
    border-left: 4px solid #3b82f6;
    padding: 1rem;
    margin-bottom: 1.5rem;
    border-radius: 4px;
}

.brainstorm-section .info-message p {
    margin: 0;
    color: #1e40af;
}

.brainstorm-section .form-card {
    background: #f9fafb;
    padding: 1.5rem;
    border-radius: 8px;
}

.brainstorm-section .form-group {
    margin-bottom: 1.5rem;
}

.brainstorm-section .form-group label {
    display: block;
    font-weight: 600;
    margin-bottom: 0.5rem;
    color: #374151;
}

.brainstorm-section .form-control {
    width: 100%;
    padding: 0.75rem;
    border: 1px solid #d1d5db;
    border-radius: 6px;
    font-size: 1rem;
    transition: border-color 0.2s;
}

.brainstorm-section .form-control:focus {
    outline: none;
    border-color: #4f46e5;
    box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
}

.brainstorm-section .form-text {
    display: block;
    margin-top: 0.25rem;
    font-size: 0.875rem;
    color: #6b7280;
}

.brainstorm-section .btn-block {
    width: 100%;
    margin-top: 1rem;
}

.brainstorm-section .results-section {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 2px solid #e5e7eb;
}

.brainstorm-section .results-section h3 {
    margin-bottom: 1rem;
    color: #1f2937;
}

.brainstorm-section .ideas-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
}

.brainstorm-section .idea-card {
    background: white;
    border: 2px solid #e5e7eb;
    border-radius: 8px;
    padding: 1.5rem;
    transition: all 0.2s;
    cursor: pointer;
}

.brainstorm-section .idea-card:hover {
    border-color: #4f46e5;
    box-shadow: 0 4px 12px rgba(79, 70, 229, 0.15);
}

.brainstorm-section .idea-card.selected {
    border-color: #4f46e5;
    background: #eff6ff;
}

.brainstorm-section .idea-card.current-idea {
    cursor: default;
}

.brainstorm-section .idea-title {
    font-size: 1.25rem;
    font-weight: 700;
    color: #1f2937;
    margin-bottom: 0.5rem;
}

.brainstorm-section .idea-premise {
    color: #4b5563;
    line-height: 1.6;
    margin-bottom: 0.75rem;
}

.brainstorm-section .idea-tags {
    display: flex;
    gap: 0.5rem;
    flex-wrap: wrap;
}

.brainstorm-section .tag {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    background: #e0e7ff;
    color: #4338ca;
    border-radius: 12px;
    font-size: 0.875rem;
    font-weight: 500;
}

.brainstorm-section .action-buttons {
    margin-top: 1.5rem;
    display: flex;
    gap: 1rem;
}

.brainstorm-section .mode-toggle {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
    background: #f9fafb;
    padding: 0.5rem;
    border-radius: 8px;
}

.brainstorm-section .mode-btn {
    flex: 1;
    padding: 0.75rem 1.5rem;
    border: 2px solid transparent;
    border-radius: 6px;
    background: white;
    color: #6b7280;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

.brainstorm-section .mode-btn:hover {
    background: #f3f4f6;
}

.brainstorm-section .mode-btn.active {
    background: #4f46e5;
    color: white;
    border-color: #4338ca;
}

.brainstorm-section textarea.form-control {
    resize: vertical;
    min-height: 100px;
}

.brainstorm-section .saved-ideas-section h4 {
    margin-bottom: 1rem;
    color: #1f2937;
    font-size: 1.2rem;
}

.brainstorm-section .genre-display {
    padding: 0.75rem;
    background: #e0e7ff;
    border: 1px solid #c7d2fe;
    border-radius: 6px;
    color: #4338ca;
    font-weight: 500;
    font-size: 1rem;
}

.progress-container {
    margin: 1.5rem 0;
    display: none;
}

.progress-bar {
    width: 100%;
    height: 30px;
    background: #e5e7eb;
    border-radius: 15px;
    overflow: hidden;
    position: relative;
}

.progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #4f46e5 0%, #7c3aed 100%);
    border-radius: 15px;
    transition: width 0.3s ease;
    width: 0%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    font-size: 0.875rem;
}

.progress-text {
    margin-top: 0.5rem;
    text-align: center;
    color: #6b7280;
    font-size: 0.875rem;
}

@media (max-width: 768px) {
    .brainstorm-section .action-buttons {
        flex-direction: column;
    }

    .brainstorm-section .action-buttons .btn {
        width: 100%;
    }
}
</style>

<script src="/static/js/project.js"></script>
<script>
const projectId = '{{ project.id }}';

// Brainstorm functionality - currentIdea initialization
let currentIdea = {{ previous_ideas|length }} > 0 ? {
    title: '{{ previous_ideas.0.title|default:"My Idea"|escapejs }}',
    premise: `{{ previous_ideas.0.premise|default:""|escapejs }}`,
    genre: '{{ previous_ideas.0.genre|default:"General"|escapejs }}'
} : null;

// Brainstorm functionality - Idea management functions
function modifyIdea() {
    document.getElementById('editSection').style.display = 'block';
    document.querySelector('.saved-ideas-section').style.display = 'none';
}

function cancelEdit() {
    document.getElementById('editSection').style.display = 'none';
    document.querySelector('.saved-ideas-section').style.display = 'block';
}

// Create Plot progress bar management
let createPlotProgressInterval = null;
let createPlotCurrentProgress = 0;

function startCreatePlotProgressBar(estimatedDuration = null) {
    const progressContainer = document.getElementById('createPlotProgressContainer');
    const progressBarFill = document.getElementById('createPlotProgressBarFill');
    const createBtn = document.getElementById('createPlotBtn');

    if (progressContainer) {
        progressContainer.style.display = 'block';
        createBtn.disabled = true;
        createBtn.style.opacity = '0.6';
        createPlotCurrentProgress = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        createPlotProgressInterval = setInterval(() => {
            if (createPlotCurrentProgress < 95) {
                createPlotCurrentProgress += increment;
                if (createPlotCurrentProgress > 95) createPlotCurrentProgress = 95;
                progressBarFill.style.width = createPlotCurrentProgress + '%';
                progressBarFill.textContent = Math.round(createPlotCurrentProgress) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeCreatePlotProgressBar() {
    const progressBarFill = document.getElementById('createPlotProgressBarFill');

    if (createPlotProgressInterval) {
        clearInterval(createPlotProgressInterval);
    }

    createPlotCurrentProgress = 100;
    progressBarFill.style.width = '100%';
    progressBarFill.textContent = '100%';
}

function resetCreatePlotProgressBar() {
    const progressContainer = document.getElementById('createPlotProgressContainer');
    const progressBarFill = document.getElementById('createPlotProgressBarFill');
    const createBtn = document.getElementById('createPlotBtn');

    if (createPlotProgressInterval) {
        clearInterval(createPlotProgressInterval);
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        createPlotCurrentProgress = 0;
        progressBarFill.style.width = '0%';
        progressBarFill.textContent = '0%';
        createBtn.disabled = false;
        createBtn.style.opacity = '1';
    }
}

async function useCurrentIdea() {
    if (!currentIdea) {
        showToast('No idea found', 'error');
        return;
    }

    if (!confirm('Create plot and characters from this idea?')) {
        return;
    }

    try {
        // Get estimated duration for plot API
        const estimatedDuration = await getEstimatedDuration('plot');
        startCreatePlotProgressBar(estimatedDuration);

        const response = await apiRequest(`/api/projects/${projectId}/create_plot/`, {
            method: 'POST',
            body: JSON.stringify({ idea_data: currentIdea })
        });

        completeCreatePlotProgressBar();
        showToast('Plot and characters created successfully!', 'success');
        setTimeout(() => {
            window.location.href = '{% url 'novels:project_detail' project.id %}';
        }, 1500);
    } catch (error) {
        resetCreatePlotProgressBar();
        showToast('Error creating plot and characters: ' + error.message, 'error');
    }
}

// Progress bar management
let progressInterval = null;
let currentProgress = 0;

function startProgressBar(estimatedDuration = null) {
    const progressContainer = document.getElementById('progressContainer');
    const progressBarFill = document.getElementById('progressBarFill');
    const saveBtn = document.getElementById('saveIdeaBtn');

    if (progressContainer) {
        progressContainer.style.display = 'block';
        saveBtn.disabled = true;
        saveBtn.style.opacity = '0.6';
        currentProgress = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            // Calculate increment to reach 95% by estimated duration
            // increment = 95 / (estimatedDuration / 2)
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        progressInterval = setInterval(() => {
            if (currentProgress < 95) {
                currentProgress += increment;
                if (currentProgress > 95) currentProgress = 95;
                progressBarFill.style.width = currentProgress + '%';
                progressBarFill.textContent = Math.round(currentProgress) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeProgressBar() {
    const progressBarFill = document.getElementById('progressBarFill');

    if (progressInterval) {
        clearInterval(progressInterval);
    }

    currentProgress = 100;
    progressBarFill.style.width = '100%';
    progressBarFill.textContent = '100%';
}

function resetProgressBar() {
    const progressContainer = document.getElementById('progressContainer');
    const progressBarFill = document.getElementById('progressBarFill');
    const saveBtn = document.getElementById('saveIdeaBtn');

    if (progressInterval) {
        clearInterval(progressInterval);
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        currentProgress = 0;
        progressBarFill.style.width = '0%';
        progressBarFill.textContent = '0%';
        saveBtn.disabled = false;
        saveBtn.style.opacity = '1';
    }
}

// Manual form submission - for new ideas
const manualForm = document.getElementById('manualForm');
if (manualForm) {
    manualForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        const projectGenre = '{{ project.genre|default:"General"|escapejs }}';
        const manualIdea = {
            title: 'My Idea',
            premise: document.getElementById('manual_premise').value,
            genre: projectGenre
        };

        try {
            // Get estimated duration for plot API
            const estimatedDuration = await getEstimatedDuration('plot');
            startProgressBar(estimatedDuration);

            // Save the idea to the database
            await apiRequest(`/api/projects/${projectId}/save_manual_idea/`, {
                method: 'POST',
                body: JSON.stringify({ idea: manualIdea })
            });

            // Automatically create plot and characters
            await apiRequest(`/api/projects/${projectId}/create_plot/`, {
                method: 'POST',
                body: JSON.stringify({ idea_data: manualIdea })
            });

            completeProgressBar();
            showToast('Idea saved and plot/characters created successfully!', 'success');

            // Redirect to project detail page
            setTimeout(() => {
                window.location.href = '{% url 'novels:project_detail' project.id %}';
            }, 1500);
        } catch (error) {
            resetProgressBar();
            showToast('Error: ' + error.message, 'error');
        }
    });
}

// Edit form submission - for modifying existing ideas
const editForm = document.getElementById('editForm');
if (editForm) {
    editForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        const projectGenre = '{{ project.genre|default:"General"|escapejs }}';
        const updatedIdea = {
            title: 'My Idea',
            premise: document.getElementById('edit_premise').value,
            genre: projectGenre
        };

        try {
            showLoading('Saving changes...');

            // Save the updated idea
            await apiRequest(`/api/projects/${projectId}/save_manual_idea/`, {
                method: 'POST',
                body: JSON.stringify({ idea: updatedIdea })
            });

            hideLoading();
            showToast('Changes saved successfully! Reloading...', 'success');

            // Reload to show updated idea
            setTimeout(() => {
                window.location.reload();
            }, 1000);
        } catch (error) {
            hideLoading();
            showToast('Error saving changes: ' + error.message, 'error');
        }
    });
}

// Mode switching for AI generation vs manual input
function switchMode(mode) {
    const generateBtn = document.querySelector('[data-mode="generate"]');
    const manualBtn = document.querySelector('[data-mode="manual"]');
    const brainstormForm = document.getElementById('brainstormForm');
    const manualForm = document.getElementById('manualForm');

    if (mode === 'generate') {
        generateBtn.classList.add('active');
        manualBtn.classList.remove('active');
        brainstormForm.style.display = 'block';
        manualForm.style.display = 'none';
    } else {
        generateBtn.classList.remove('active');
        manualBtn.classList.add('active');
        brainstormForm.style.display = 'none';
        manualForm.style.display = 'block';
    }
}

// AI brainstorm form submission
const brainstormForm = document.getElementById('brainstormForm');
if (brainstormForm) {
    brainstormForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        const projectGenre = '{{ project.genre|default:""|escapejs }}';
        if (!projectGenre) {
            showToast('Please set a genre for your project first', 'error');
            return;
        }

        const formData = {
            genre: projectGenre,
            theme: document.getElementById('theme').value || undefined,
            num_ideas: parseInt(document.getElementById('num_ideas').value)
        };

        generateIdeas(formData);
    });
}

// Brainstorm progress bar management
let brainstormProgressInterval = null;
let brainstormCurrentProgress = 0;

function startBrainstormProgressBar(estimatedDuration = null) {
    const progressContainer = document.getElementById('brainstormProgressContainer');
    const progressBarFill = document.getElementById('brainstormProgressBarFill');
    const generateBtn = document.getElementById('generateIdeasBtn');

    if (progressContainer) {
        progressContainer.style.display = 'block';
        generateBtn.disabled = true;
        generateBtn.style.opacity = '0.6';
        brainstormCurrentProgress = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            // Calculate increment to reach 95% by estimated duration
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        brainstormProgressInterval = setInterval(() => {
            if (brainstormCurrentProgress < 95) {
                brainstormCurrentProgress += increment;
                if (brainstormCurrentProgress > 95) brainstormCurrentProgress = 95;
                progressBarFill.style.width = brainstormCurrentProgress + '%';
                progressBarFill.textContent = Math.round(brainstormCurrentProgress) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeBrainstormProgressBar() {
    const progressBarFill = document.getElementById('brainstormProgressBarFill');

    if (brainstormProgressInterval) {
        clearInterval(brainstormProgressInterval);
    }

    brainstormCurrentProgress = 100;
    progressBarFill.style.width = '100%';
    progressBarFill.textContent = '100%';
}

function resetBrainstormProgressBar() {
    const progressContainer = document.getElementById('brainstormProgressContainer');
    const progressBarFill = document.getElementById('brainstormProgressBarFill');
    const generateBtn = document.getElementById('generateIdeasBtn');

    if (brainstormProgressInterval) {
        clearInterval(brainstormProgressInterval);
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        brainstormCurrentProgress = 0;
        progressBarFill.style.width = '0%';
        progressBarFill.textContent = '0%';
        generateBtn.disabled = false;
        generateBtn.style.opacity = '1';
    }
}

async function generateIdeas(data) {
    // Get estimated duration for brainstorm API
    const estimatedDuration = await getEstimatedDuration('brainstorm');
    startBrainstormProgressBar(estimatedDuration);

    apiRequest(`/api/projects/${projectId}/brainstorm/`, {
        method: 'POST',
        body: JSON.stringify(data)
    }).then(response => {
        showToast('Ideas generation started!', 'success');
        pollTask(response.task_id);
    }).catch(error => {
        resetBrainstormProgressBar();
        showToast('Error generating ideas: ' + error.message, 'error');
    });
}

function pollTask(taskId) {
    const interval = setInterval(() => {
        apiRequest(`/api/tasks/${taskId}/`)
            .then(task => {
                if (task.status === 'completed') {
                    clearInterval(interval);
                    completeBrainstormProgressBar();
                    setTimeout(() => {
                        resetBrainstormProgressBar();
                        displayIdeas(task.result_data.ideas);
                    }, 500);
                } else if (task.status === 'failed') {
                    clearInterval(interval);
                    resetBrainstormProgressBar();
                    showToast('Failed to generate ideas: ' + task.error_message, 'error');
                }
            })
            .catch(error => {
                clearInterval(interval);
                resetBrainstormProgressBar();
                showToast('Error checking task status', 'error');
            });
    }, 2000);
}

function displayIdeas(ideas) {
    const container = document.getElementById('ideasContainer');
    const resultsSection = document.getElementById('resultsSection');

    container.innerHTML = '';

    ideas.forEach((idea, index) => {
        const card = document.createElement('div');
        card.className = 'idea-card';
        card.dataset.index = index;

        card.innerHTML = `
            <div class="idea-title">${idea.title || 'Idea ' + (index + 1)}</div>
            <div class="idea-premise">${idea.premise || idea.description || ''}</div>
            ${idea.genre ? `<div class="idea-tags"><span class="tag">${idea.genre}</span></div>` : ''}
        `;

        card.addEventListener('click', () => selectIdea(card, idea));
        container.appendChild(card);
    });

    // Add action buttons
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'action-buttons';
    actionsDiv.innerHTML = `
        <div style="flex: 1;">
            <button class="btn btn-primary" id="useSelectedBtn" disabled style="width: 100%; opacity: 0.5;">Save Idea and continue</button>
            <small id="selectReminder" style="display: block; margin-top: 0.5rem; color: #6b7280; text-align: center;">Select an idea to continue</small>
        </div>
        <button class="btn btn-secondary" onclick="window.location.href='{% url 'novels:project_detail' project.id %}'">Back to Project</button>
    `;
    container.appendChild(actionsDiv);

    document.getElementById('useSelectedBtn').addEventListener('click', useSelectedIdea);

    resultsSection.style.display = 'block';
    resultsSection.scrollIntoView({ behavior: 'smooth' });
}

let selectedIdea = null;

function selectIdea(card, idea) {
    document.querySelectorAll('.idea-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    selectedIdea = idea;

    const useBtn = document.getElementById('useSelectedBtn');
    const reminder = document.getElementById('selectReminder');

    if (useBtn) {
        useBtn.disabled = false;
        useBtn.style.opacity = '1';
    }

    if (reminder) {
        reminder.style.display = 'none';
    }
}

function useSelectedIdea() {
    if (!selectedIdea) {
        showToast('Please select an idea first', 'error');
        return;
    }

    if (!confirm('Use this idea to create the plot and characters for your novel?')) {
        return;
    }

    showLoading('Creating plot and characters...');

    apiRequest(`/api/projects/${projectId}/create_plot/`, {
        method: 'POST',
        body: JSON.stringify({ idea_data: selectedIdea })
    }).then(response => {
        hideLoading();
        showToast('Plot and characters created successfully!', 'success');
        setTimeout(() => {
            window.location.href = '{% url 'novels:project_detail' project.id %}';
        }, 1500);
    }).catch(error => {
        hideLoading();
        showToast('Error creating plot and characters: ' + error.message, 'error');
    });
}

// Tab switching
document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        showTab(tabName);
    });
});

// Restore tab from URL hash on page load
window.addEventListener('DOMContentLoaded', function() {
    const hash = window.location.hash.substring(1); // Remove the '#'
    if (hash && document.getElementById(hash)) {
        showTab(hash);
    }
});

function showTab(tabName) {
    // Close any open modals when switching tabs
    if (typeof closeNovelTextModal === 'function') {
        closeNovelTextModal();
    }

    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    document.getElementById(tabName).classList.add('active');

    // Update URL hash to preserve tab state across page reloads
    window.location.hash = tabName;
}

function startBrainstorm() {
    window.location.href = `/project/${projectId}/brainstorm/`;
}

// Create Outline progress bar management
let createOutlineProgressInterval = null;
let createOutlineCurrentProgress = 0;
let createOutlinePollingInterval = null;

function startCreateOutlineProgressBar(estimatedDuration = null) {
    const progressContainer = document.getElementById('createOutlineProgressContainer');
    const progressBarFill = document.getElementById('createOutlineProgressBarFill');

    if (progressContainer) {
        progressContainer.style.display = 'block';
        createOutlineCurrentProgress = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        createOutlineProgressInterval = setInterval(() => {
            if (createOutlineCurrentProgress < 95) {
                createOutlineCurrentProgress += increment;
                if (createOutlineCurrentProgress > 95) createOutlineCurrentProgress = 95;
                progressBarFill.style.width = createOutlineCurrentProgress + '%';
                progressBarFill.textContent = Math.round(createOutlineCurrentProgress) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeCreateOutlineProgressBar() {
    const progressBarFill = document.getElementById('createOutlineProgressBarFill');

    if (createOutlineProgressInterval) {
        clearInterval(createOutlineProgressInterval);
    }

    createOutlineCurrentProgress = 100;
    progressBarFill.style.width = '100%';
    progressBarFill.textContent = '100%';
}

function resetCreateOutlineProgressBar() {
    const progressContainer = document.getElementById('createOutlineProgressContainer');
    const progressBarFill = document.getElementById('createOutlineProgressBarFill');

    if (createOutlineProgressInterval) {
        clearInterval(createOutlineProgressInterval);
    }

    if (createOutlinePollingInterval) {
        clearInterval(createOutlinePollingInterval);
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        createOutlineCurrentProgress = 0;
        progressBarFill.style.width = '0%';
        progressBarFill.textContent = '0%';
    }
}

async function createOutline() {
    const numChapters = prompt('How many chapters do you want to create?', '1');

    // If user clicks Cancel, numChapters will be null
    if (numChapters === null) return;

    // If user clicks OK without typing anything, use default of 1
    const chapters = parseInt(numChapters || '1');
    if (isNaN(chapters) || chapters < 1 || chapters > 100) {
        showToast('Please enter a valid number between 1 and 100', 'error');
        return;
    }

    console.log('Creating outline with num_chapters:', chapters);

    if (!confirm(`Create outline with ${chapters} chapters? This may take a few moments.`)) return;

    try {
        // Get estimated duration for outline API
        const estimatedDuration = await getEstimatedDuration('outline');
        startCreateOutlineProgressBar(estimatedDuration);

        const response = await apiRequest(`/api/projects/${projectId}/create_outline/`, {
            method: 'POST',
            body: JSON.stringify({ num_chapters: chapters })
        });

        showToast('Outline generation started!', 'success');

        // Poll task status
        createOutlinePollingInterval = setInterval(async () => {
            try {
                const task = await apiRequest(`/api/tasks/${response.task_id}/`);

                if (task.status === 'completed') {
                    clearInterval(createOutlinePollingInterval);
                    completeCreateOutlineProgressBar();
                    showToast('Outline created successfully!', 'success');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else if (task.status === 'failed') {
                    clearInterval(createOutlinePollingInterval);
                    resetCreateOutlineProgressBar();
                    showToast('Failed to create outline: ' + (task.error_message || 'Unknown error'), 'error');
                }
            } catch (error) {
                clearInterval(createOutlinePollingInterval);
                resetCreateOutlineProgressBar();
                showToast('Error checking task status', 'error');
            }
        }, 2000);

    } catch (err) {
        resetCreateOutlineProgressBar();
        showToast('Error creating outline', 'error');
    }
}

function scoreNovel() {
    if (!confirm('Score your novel? This will analyze all chapters.')) return;

    showLoading('Scoring novel...');
    apiRequest(`/api/projects/${projectId}/score/`, {
        method: 'POST'
    }).then(data => {
        showToast('Scoring started!', 'success');
        connectToTask(data.task_id);
    }).catch(err => {
        hideLoading();
        showToast('Error scoring novel', 'error');
    });
}

async function writeChapterFromOutline(outlineId) {
    // Prompt for word count
    const wordCount = prompt('How many words should this chapter be? (10-10000)', '10');

    if (wordCount === null) return; // User cancelled

    const words = parseInt(wordCount);
    if (isNaN(words) || words < 10 || words > 10000) {
        showToast('Please enter a valid word count between 10 and 10000', 'error');
        return;
    }

    if (!confirm(`Write this chapter with approximately ${words} words?`)) return;

    try {
        // Get estimated duration for chapter API
        const estimatedDuration = await getEstimatedDuration('chapter');
        startWriteChapterProgressBar(outlineId, estimatedDuration);

        const response = await apiRequest(`/api/projects/${projectId}/write_chapter/`, {
            method: 'POST',
            body: JSON.stringify({
                chapter_outline_id: outlineId,
                writing_style: 'literary',
                target_word_count: words
            })
        });

        showToast('Chapter writing started!', 'success');

        // Poll task status
        writeChapterPollingIntervals[outlineId] = setInterval(async () => {
            try {
                const task = await apiRequest(`/api/tasks/${response.task_id}/`);

                if (task.status === 'completed') {
                    clearInterval(writeChapterPollingIntervals[outlineId]);
                    completeWriteChapterProgressBar(outlineId);
                    showToast('Chapter written successfully!', 'success');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else if (task.status === 'failed') {
                    clearInterval(writeChapterPollingIntervals[outlineId]);
                    resetWriteChapterProgressBar(outlineId);
                    showToast('Failed to write chapter: ' + (task.error_message || 'Unknown error'), 'error');
                }
            } catch (error) {
                clearInterval(writeChapterPollingIntervals[outlineId]);
                resetWriteChapterProgressBar(outlineId);
                showToast('Error checking task status', 'error');
            }
        }, 2000);

    } catch (err) {
        resetWriteChapterProgressBar(outlineId);
        showToast('Error writing chapter: ' + err.message, 'error');
    }
}

// Write Chapter progress bar management
let writeChapterProgressIntervals = {};
let writeChapterCurrentProgress = {};
let writeChapterPollingIntervals = {};

function startWriteChapterProgressBar(outlineId, estimatedDuration = null) {
    const progressContainer = document.getElementById(`writeChapterProgressContainer-${outlineId}`);
    const progressBarFill = document.getElementById(`writeChapterProgressBarFill-${outlineId}`);
    const writeChapterBtn = document.getElementById(`writeChapterBtn-${outlineId}`);

    if (progressContainer) {
        progressContainer.style.display = 'block';
        if (writeChapterBtn) {
            writeChapterBtn.disabled = true;
            writeChapterBtn.style.opacity = '0.6';
        }
        writeChapterCurrentProgress[outlineId] = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        writeChapterProgressIntervals[outlineId] = setInterval(() => {
            if (writeChapterCurrentProgress[outlineId] < 95) {
                writeChapterCurrentProgress[outlineId] += increment;
                if (writeChapterCurrentProgress[outlineId] > 95) writeChapterCurrentProgress[outlineId] = 95;
                progressBarFill.style.width = writeChapterCurrentProgress[outlineId] + '%';
                progressBarFill.textContent = Math.round(writeChapterCurrentProgress[outlineId]) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeWriteChapterProgressBar(outlineId) {
    const progressBarFill = document.getElementById(`writeChapterProgressBarFill-${outlineId}`);

    if (writeChapterProgressIntervals[outlineId]) {
        clearInterval(writeChapterProgressIntervals[outlineId]);
    }

    writeChapterCurrentProgress[outlineId] = 100;
    if (progressBarFill) {
        progressBarFill.style.width = '100%';
        progressBarFill.textContent = '100%';
    }
}

function resetWriteChapterProgressBar(outlineId) {
    const progressContainer = document.getElementById(`writeChapterProgressContainer-${outlineId}`);
    const progressBarFill = document.getElementById(`writeChapterProgressBarFill-${outlineId}`);
    const writeChapterBtn = document.getElementById(`writeChapterBtn-${outlineId}`);

    if (writeChapterProgressIntervals[outlineId]) {
        clearInterval(writeChapterProgressIntervals[outlineId]);
        delete writeChapterProgressIntervals[outlineId];
    }

    if (writeChapterPollingIntervals[outlineId]) {
        clearInterval(writeChapterPollingIntervals[outlineId]);
        delete writeChapterPollingIntervals[outlineId];
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        writeChapterCurrentProgress[outlineId] = 0;
        if (progressBarFill) {
            progressBarFill.style.width = '0%';
            progressBarFill.textContent = '0%';
        }
        if (writeChapterBtn) {
            writeChapterBtn.disabled = false;
            writeChapterBtn.style.opacity = '1';
        }
    }
}

// Regenerate Outline progress bar management
let regenerateProgressIntervals = {};
let regenerateCurrentProgress = {};
let regeneratePollingIntervals = {};

function startRegenerateProgressBar(chapterNumber, estimatedDuration = null) {
    const progressContainer = document.getElementById(`regenerateProgressContainer-${chapterNumber}`);
    const progressBarFill = document.getElementById(`regenerateProgressBarFill-${chapterNumber}`);
    const regenerateBtn = document.getElementById(`regenerateBtn-${chapterNumber}`);

    if (progressContainer) {
        progressContainer.style.display = 'block';
        if (regenerateBtn) {
            regenerateBtn.disabled = true;
            regenerateBtn.style.opacity = '0.6';
        }
        regenerateCurrentProgress[chapterNumber] = 0;

        // Calculate increment based on estimated duration or use default
        let increment = 5; // Default: 5% every 2 seconds
        if (estimatedDuration) {
            increment = Math.max(1, Math.min(95 / (estimatedDuration / 2), 10));
        }

        regenerateProgressIntervals[chapterNumber] = setInterval(() => {
            if (regenerateCurrentProgress[chapterNumber] < 95) {
                regenerateCurrentProgress[chapterNumber] += increment;
                if (regenerateCurrentProgress[chapterNumber] > 95) regenerateCurrentProgress[chapterNumber] = 95;
                progressBarFill.style.width = regenerateCurrentProgress[chapterNumber] + '%';
                progressBarFill.textContent = Math.round(regenerateCurrentProgress[chapterNumber]) + '%';
            }
        }, 2000); // Update every 2 seconds
    }
}

function completeRegenerateProgressBar(chapterNumber) {
    const progressBarFill = document.getElementById(`regenerateProgressBarFill-${chapterNumber}`);

    if (regenerateProgressIntervals[chapterNumber]) {
        clearInterval(regenerateProgressIntervals[chapterNumber]);
    }

    regenerateCurrentProgress[chapterNumber] = 100;
    if (progressBarFill) {
        progressBarFill.style.width = '100%';
        progressBarFill.textContent = '100%';
    }
}

function resetRegenerateProgressBar(chapterNumber) {
    const progressContainer = document.getElementById(`regenerateProgressContainer-${chapterNumber}`);
    const progressBarFill = document.getElementById(`regenerateProgressBarFill-${chapterNumber}`);
    const regenerateBtn = document.getElementById(`regenerateBtn-${chapterNumber}`);

    if (regenerateProgressIntervals[chapterNumber]) {
        clearInterval(regenerateProgressIntervals[chapterNumber]);
        delete regenerateProgressIntervals[chapterNumber];
    }

    if (regeneratePollingIntervals[chapterNumber]) {
        clearInterval(regeneratePollingIntervals[chapterNumber]);
        delete regeneratePollingIntervals[chapterNumber];
    }

    if (progressContainer) {
        progressContainer.style.display = 'none';
        regenerateCurrentProgress[chapterNumber] = 0;
        if (progressBarFill) {
            progressBarFill.style.width = '0%';
            progressBarFill.textContent = '0%';
        }
        if (regenerateBtn) {
            regenerateBtn.disabled = false;
            regenerateBtn.style.opacity = '1';
        }
    }
}

async function regenerateOutline(chapterNumber) {
    if (!confirm(`Regenerate outline for chapter ${chapterNumber}? This will replace the current outline with a new version.`)) return;

    try {
        // Get estimated duration for outline API
        const estimatedDuration = await getEstimatedDuration('outline');
        startRegenerateProgressBar(chapterNumber, estimatedDuration);

        const response = await apiRequest(`/api/projects/${projectId}/regenerate_chapter_outline/`, {
            method: 'POST',
            body: JSON.stringify({ chapter_number: chapterNumber })
        });

        showToast('Outline regeneration started!', 'success');

        // Poll task status
        regeneratePollingIntervals[chapterNumber] = setInterval(async () => {
            try {
                const task = await apiRequest(`/api/tasks/${response.task_id}/`);

                if (task.status === 'completed') {
                    clearInterval(regeneratePollingIntervals[chapterNumber]);
                    completeRegenerateProgressBar(chapterNumber);
                    showToast('Outline regenerated successfully!', 'success');
                    setTimeout(() => {
                        window.location.reload();
                    }, 1500);
                } else if (task.status === 'failed') {
                    clearInterval(regeneratePollingIntervals[chapterNumber]);
                    resetRegenerateProgressBar(chapterNumber);
                    showToast('Failed to regenerate outline: ' + (task.error_message || 'Unknown error'), 'error');
                }
            } catch (error) {
                clearInterval(regeneratePollingIntervals[chapterNumber]);
                resetRegenerateProgressBar(chapterNumber);
                showToast('Error checking task status', 'error');
            }
        }, 2000);

    } catch (err) {
        resetRegenerateProgressBar(chapterNumber);
        showToast('Error regenerating outline: ' + err.message, 'error');
    }
}

function deleteOutline(outlineId) {
    if (!confirm('Delete this chapter outline? This cannot be undone.')) return;

    showLoading('Deleting outline...');
    apiRequest(`/api/projects/${projectId}/delete_outline/${outlineId}/`, {
        method: 'DELETE'
    }).then(() => {
        hideLoading();
        showToast('Outline deleted successfully!', 'success');
        setTimeout(() => window.location.reload(), 1000);
    }).catch(err => {
        hideLoading();
        showToast('Error deleting outline: ' + err.message, 'error');
    });
}

function deleteChapter(chapterId) {
    if (!confirm('Delete this chapter? This cannot be undone and all content will be lost.')) return;

    showLoading('Deleting chapter...');
    apiRequest(`/api/chapters/${chapterId}/`, {
        method: 'DELETE'
    }).then(() => {
        hideLoading();
        showToast('Chapter deleted successfully!', 'success');
        setTimeout(() => window.location.reload(), 1000);
    }).catch(err => {
        hideLoading();
        showToast('Error deleting chapter: ' + err.message, 'error');
    });
}

function downloadNovel() {
    window.location.href = `/api/projects/${projectId}/export/`;
}

function viewNovelOnline() {
    showLoading('Loading novel text...');
    apiRequest(`/api/projects/${projectId}/view_text/`, {
        method: 'GET'
    }).then(data => {
        hideLoading();
        if (!data || !data.full_text) {
            showToast('No content available to display', 'warning');
            return;
        }
        showNovelTextModal(data);
    }).catch(err => {
        hideLoading();
        showToast('Error loading novel text: ' + err.message, 'error');
    });
}

function showNovelTextModal(data) {
    // Remove any existing modal first
    closeNovelTextModal();

    // Create modal overlay with inline styles for guaranteed positioning
    const overlay = document.createElement('div');
    overlay.className = 'novel-text-overlay';
    overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        padding: 20px;
    `;

    // Escape HTML to prevent XSS and rendering issues
    const escapeHtml = (text) => {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    };

    // Create modal structure
    const modal = document.createElement('div');
    modal.className = 'novel-text-modal';
    modal.style.cssText = `
        background: white;
        border-radius: 12px;
        width: 100%;
        max-width: 900px;
        max-height: 90vh;
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    `;

    // Create header
    const header = document.createElement('div');
    header.className = 'novel-text-header';
    header.style.cssText = `
        padding: 20px;
        border-bottom: 2px solid #E5E7EB;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 16px;
    `;
    header.innerHTML = `
        <div>
            <h2 style="margin: 0; color: #111827; font-size: 24px;">${escapeHtml(data.title)}</h2>
            <p style="margin: 8px 0 0 0; color: #6B7280; font-size: 14px;">by ${escapeHtml(data.author)} | ${escapeHtml(data.genre)} | ${data.chapter_count} chapters | ${data.total_word_count} words</p>
        </div>
        <button class="btn btn-sm btn-danger" onclick="closeNovelTextModal()">‚úï Close</button>
    `;

    // Create content area
    const contentDiv = document.createElement('div');
    contentDiv.className = 'novel-text-content';
    contentDiv.style.cssText = `
        flex: 1;
        overflow-y: auto;
        padding: 20px;
    `;

    const preElement = document.createElement('pre');
    preElement.style.cssText = `
        margin: 0;
        white-space: pre-wrap;
        word-wrap: break-word;
        font-family: 'Georgia', 'Times New Roman', serif;
        font-size: 16px;
        line-height: 1.8;
        color: #111827;
    `;
    preElement.textContent = data.full_text || '';
    contentDiv.appendChild(preElement);

    // Assemble modal
    modal.appendChild(header);
    modal.appendChild(contentDiv);
    overlay.appendChild(modal);

    // Click outside to close
    overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
            closeNovelTextModal();
        }
    });

    // Prevent clicks inside modal from closing it
    modal.addEventListener('click', (e) => {
        e.stopPropagation();
    });

    document.body.appendChild(overlay);
    document.body.style.overflow = 'hidden';
}

function closeNovelTextModal() {
    // Remove all overlay instances (in case there are multiple)
    const overlays = document.querySelectorAll('.novel-text-overlay');
    overlays.forEach(overlay => overlay.remove());

    // Restore body scroll
    document.body.style.overflow = '';
}

// Close modal on Escape key
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' || e.keyCode === 27) {
        closeNovelTextModal();
    }
});

// Clean up any orphaned modals on page load
window.addEventListener('DOMContentLoaded', function() {
    closeNovelTextModal();
});

// Clean up modals before page unload
window.addEventListener('beforeunload', function() {
    closeNovelTextModal();
});
</script>
{% endblock %}
